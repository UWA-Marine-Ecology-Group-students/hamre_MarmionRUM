Script to make AC grid for Marmion

```{r setup}
# knitr options
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE, fig.align = 'center', fig.width = 10, fig.height = 7) 

# libraries 
library(tidyverse)
library(dplyr)
library(ggplot2)
library(sp)
library(raster)
library(rgeos)
library(rgdal)
library(sf)
library(lwgeom)
library(googledrive)
library(units)
library(nngeo)
library(magrittr)
library(todor)

# data
sites <- st_read("./data/gpkg/ac_grid_4283.gpkg") 
BR <- st_read("./data/gpkg/BR_4283.gpkg") # boat ramps
BRtrips <- readRDS("./data/gpkg/2.1_BRtrips.gpkg")
npz <- readRDS("./data/gpkg/2.1_acNPZ_4283.gpkg")
sim <- readRDS("./data/gpkg/ac_sim1_sz.gpkg")
comm <- st_read("./data/gpkg/commwater.gpkg")
state <- st_read("./data/gpkg/statewater.gpkg")
water <- readRDS("./data/gpkg/2.1_acStudySite_4283.gpkg")

dat <- read_csv("data/01_data/1.2_dat.csv") %>% 
  filter(ActivityType == "Extractive") %>%
  filter(!is.na(UseLat), !is.na(UseLong)) %>% 
  st_as_sf(coords = c("UseLong", "UseLat"), crs = 4283)


# functions
source("./functions/spatialFunc.R") # spatial functions

sf_use_s2(FALSE)

# testing layers
# ggplot() +
#   geom_sf(data = state) +
#   geom_sf(data = comm, fill = 'red') +
#   geom_sf(data = sim) +
#   geom_sf(data = npz, fill = 'blue') +
#   geom_sf(data = BR)
```

# Make choice set (grid)
## Cleaning layers

```{r}
sf_obj <- list(sites, BR, BRtrips, npz, sim, comm, state, water) # TODO: automate file listing
lapply(sf_obj, st_transform, crs = 4283) # FIX: doesnt work sim still a different crs

# add npz col, all should be 1 and filled in with 0 when data expanded
npz <- npz %>% 
  mutate(npz = 1)

# add sz col all should be 1, and row numbers for loop
sim %<>% 
  mutate(sz = 1) %>%
  mutate(id = row_number())

# make a new binary column for each sanctuary zone
for (i in 1:nrow(sim)) {
  sz = ifelse(sim$id == i, 1, 0)
  sim[,length(sim) + 1 ] <- sz 
  colnames(sim)[ncol(sim)] <- paste0("sz", i)
}

# removing unecessary attributes
comm %<>% dplyr::select(geom) %>% st_transform(crs(sim))

state %<>% dplyr::select(geom) %>% st_transform(crs(sim))
```


# turning bathy into contours
```{r}
## turn extract contours from bathy
# contours <- st_as_sf(rasterToContour(bathy, maxpixels = 2500, levels = c(-20, -50)))
# 
# contours %<>% st_transform(crs(water))
# 
# contours %<>% st_crop(water) %>% rename(depth = level)
```

```{r}
#stopped working
# state_line <- st_intersection(comm, state) %>% # extracting lin in common between comm and state
#   mutate(id = row_number()) # need attributes to split by lines
# 
# vert_split <- st_split(water, state_line) # splitting by lines
# vert_split <- st_collection_extract(vert_split) # extract list

vert_split <- rbind(comm, state)

ggplot() +
  geom_sf(data = vert_split)

# nrow(vert_split) == 2
```
# Make base grid
```{r}
sim %<>% st_transform(crs(npz))

sim_holes <- st_difference(sim, st_combine(npz)) # cut npz out of sims

# joining sims and npz while maintaining attributes
sim_holes_df <- sim_holes %>% as.data.frame() %>% mutate(geom = as.character(geom))
npz_df <- npz %>% as.data.frame() %>% mutate(geom = as.character(geom))

ntz <- full_join(sim_holes_df, npz_df) %>% 
  mutate(id = row_number()) %>% 
  mutate_if(is.numeric, ~replace_na(., 0))

sim_holes_geom <- st_as_sf(sim_holes$geom)
npz_geom <- st_as_sf(npz$geom)

ntz_geom <- rbind(sim_holes_geom, npz_geom)

ntz <- cbind(ntz, ntz_geom) %>% 
  st_as_sf() %>% 
  dplyr::select(-geom) %>% 
  rename(geom = x)

# nrow(ntz) == nrow(npz) + nrow(sim) # TRUE
  
vert_split %<>% st_transform(crs(ntz))

vert_split_holes <- st_difference(vert_split, st_combine(ntz)) # cut npz out of sims

vert_split_holes_df <- vert_split_holes %>% as.data.frame() %>% mutate(id = row_number()) %>%  mutate(geom = as.character(geom))
ntz_df <- ntz %>% as.data.frame() %>% mutate(geom = as.character(geom))

base_grid <- full_join(vert_split_holes_df, ntz_df) %>% 
  mutate(id = row_number()) %>% 
  mutate_if(is.numeric, ~replace_na(., 0))

vert_split_holes_geom <- st_as_sf(vert_split_holes$geom)
ntz_geom <- st_as_sf(ntz$geom)

base_grid_geom <- rbind(vert_split_holes_geom, ntz_geom)

base_grid <- cbind(base_grid, base_grid_geom) %>% 
  st_as_sf() %>% 
  dplyr::select(-geom) %>% 
  rename(geom = x) %>% 
  mutate(ntz = ifelse(npz == 1 | sz == 1, 1, 0))



# checks
nrow(base_grid) == nrow(vert_split) + nrow(ntz) # TRUE

# check geometries
ggplot() +
  geom_sf(data = base_grid, aes(color = as.factor(sz), fill = as.factor(npz)))

ggplot() +
  geom_sf(data = base_grid, aes(fill = as.factor(ntz)))
```

Trying to make lines to split polygons in base grid
Needs to be at least one data point in ecah grid

For every polygon (row in base_grid) when ntz == 0
  - draw a line 3 km south of top border
  - check to see if there is a data point above it/in new polygon 
  - if yes start new line 
  - if no start 4 km south, if no again start 5km south so on 
  
```{r}
# for (i in 1:3) {
#   l <- st_linestring(matrix(
#     c(xminmax[1],
#       df2[i, "lat"],
#       xminmax[2],
#       df2[i, "lat"]),
#     nrow = 2,
#     byrow = TRUE
#   ))
#   # Create final object line
#   if (i == 1) {
#     line <- l
#   } else {
#     line <- c(line, l)
#   }
# }

d <- st_sfc(st_linestring(matrix(c(115.1, -31.4, 115.7, -31.4), nrow = 2, byrow = TRUE), 
                          dim = "XY"))
st_crs(d) = crs(base_grid)

# e <- st_sfc(st_multilinestring(list(matrix(c(1, 5, 5, 5), nrow = 2, byrow = TRUE), 
#                              matrix(c(5, 1, 1, 1), nrow = 2, byrow = TRUE)
#                              ), dim = "XY"))
# st_crs(e) = crs(state)
# state %<>% st_transform(4283)
# 
# d %<>% st_intersection(state)
# 
# ##
# 
# d %<>% st_cast("LINESTRING") %>% st_collection_extract("LINESTRING")
# 
# d %<>% st_as_sf()
# 
# a <- st_split(d, base_grid)
# 
# b <- st_collection_extract(a, "LINESTRING")
# 
# c <- st_polygonize(b)


# split by lines removes all attributes, see if there is another way

# state_holes <- st_difference(state, st_combine(ntz)) # 

# state_holes <-  st_collection_extract(state_holes, c("POLYGON"))
# 
# 
# a <- state_holes %>% st_subdivide(3000) %>% st_collection_extract("POLYGON")
# a %<>% mutate(id = row_number(),
#               area = round(set_units(st_area(.), km^2), 2),
#               area = as.numeric(area))
#   
# a %<>% filter(area > 1)

# st_intersects(a, dat, sparse = FALSE)

# st_crs(bbox, parameters = TRUE)$units_gdal
# 
# bbox <- st_as_sfc(st_bbox(state_holes)) 

# bbox <- st_bbox(state_holes)
# g1 <- state_holes %>% st_make_grid(cellsize = c(bbox$xmax-bbox$xmin, 0.05))
# g1state <- st_intersection(state_holes, g1)
# g1state$area <- as.numeric(round(set_units(st_area(g1state), km^2), 2))
# g2state <- g1state %>% filter(area > 20)
# 
# 
# g2dat <- st_join(g2state, dat, join = st_intersects)
# 
# a <- as.data.frame(st_intersects(g2state, dat, sparse = FALSE))
#    
# b <- a %>% 
#   rowwise %>% 
#    mutate(inPoly = if_any(starts_with('V'), ~. == TRUE)) %>%
#    ungroup()
# 
# g2state$dat <- b$inPoly
# 
# g2false <- g2state %>% filter(dat == FALSE)
# 
# hGrid <- seq(from = 0.03, by = 0.02)

# add in combination of sim and npz 

#ASCgrid function, makes automated and customisable grid for a alternative specific constant RUM. This function will create horizontal lines across a polygon, and check there is a spatial use data point in each cell. The function will iterate, making the grid gradually bigger with each iteration until there is at leats one data point in every cell. 
#
# ARGUMENTS
# poly: an sf object which the grid is to be made in
# ntz: a sf object of the npz an simulations 
# point: spatial use data to be used in RUM
# from: distance between horizontal line - unit to be same as polygon crs (default 0.03 degrees)
# by: change in distance between horizontal line with each iteration - units to be the same as poly crs (default 0.02 degrees)
# min_area: define the minimum allowable area of grid cells. 

ASCgrid <- function(poly, ntz, point, from = 0.03, by = 0.02, min_area = 20) {
  poly_w_ntz <- st_difference(poly, st_combine(ntz))
  bbox <- st_bbox(poly_w_ntz) # make bbox
  hGrid <- seq(from = from, by = by) # make sequence
  # makes grid & checks data presents, if not loops over next grid
  
  for (i in hGrid) { 
    grid <- poly_w_ntz %>% st_make_grid(cellsize = c(bbox$xmax - bbox$xmin, i))
    grid <- st_intersection(poly_w_ntz, grid)
    grid$area <- as.numeric(round(set_units(st_area(grid), km^2), 2))
    grid %<>% filter(area > min_area)
    temp <- as.data.frame(st_intersects(grid, point, sparse = FALSE)) %>%
      rowwise %>% 
      mutate(inpoly_w_ntz = if_any(starts_with('V'), ~. == TRUE)) %>%
      ungroup()
      grid$data_present <- temp$inpoly_w_ntz
      
      if (any(grid$data_present == FALSE)) {
        print(paste0("Missing data (", i ,"), making new grid"))
      } else {
        print(paste(i, "Grid", sep = " "))
        print(grid)
        print(
          ggplot() +
          geom_sf(data = point) +
          geom_sf(data = grid, alpha = 0)
        )
        return(grid)
        break
      }
  }
}

t <- ASCgrid(poly = state, ntz = ntz, point = dat, from = 0.03, by = 0.02, min_area = 45)

comm %<>% st_transform(crs(ntz))

t2 <- ASCgrid(poly = comm, ntz = ntz, point = dat)

t <- ASCgrid(poly = state_holes, point = dat)



ggplot() +
  # geom_sf(data = a, aes(fill = as.factor(id))) +
  geom_sf(data = dat) +
   # geom_sf(data = a)
   # geom_sf(data = bbox) +
  # geom_sf(data = state_holes) +
  geom_sf(data = t, alpha = 0)
```


# Prep data
```{r}
# Site daat (AC grid)
sites <- sites %>% 
  mutate(SZ = ifelse(SZ1 %in% 1, 1, 
                     ifelse(SZ2 %in% 1, 1,
                            ifelse(SZ3 %in% 1, 1, 
                                   ifelse(SZ4 %in% 1, 1,
                                          ifelse(SZ5 %in% 1, 1, 0)))))) %>% # binary SZ  var
  mutate(gridID = row_number()) # adding unique ID
  
site_centroid <- st_centroid_within_poly(sites) # gets centroid of every grid cell
sites$site_centroid <- site_centroid$geom # appending centroid

# getting distance from each boat rampe to the centroid of the sites
BR <- st_transform(BR, crs(sites))
dist <- as.data.frame(set_units(st_distance(sites$site_centroid, BR), km)) 
names(dist) <- unique(BR$RampID)
gridID <- sites$gridID
dist$gridID <- gridID
dist <- dist %>% gather("BR", "site.centroid_km.BR", 1:length(dist) - 1) 
sites <- sites %>% left_join(dist, by = "gridID") # join 

sites <- sites |> st_sf() |> # wont work without st_sf()
  rename(gridID_alt = gridID) %>%
  dplyr::select(-site_centroid) 


gridID_vis <- sites %>% 
  dplyr::select(gridID_alt, geom) %>% 
  distinct() 

st_write(gridID_vis, "./data/gpkg/2.1_acChoiceSetQ_4283.gpkg", append = FALSE) # need to write with st_write to open in QGISRUMs
# check 
# ggplot() +
#   geom_sf(data = sites$geom, aes(fill = sites$SZ)) +
#   geom_sf(data = sites$site_centroid, color = 'red')
```

```{r}
# Use spatial points
dat <- st_crop(dat, sites) # removing outliers

# need one trip per row (longest site visited on trip)
dat <- dat %>% 
  group_by(PersonID, TripID) %>% 
  slice(which.max(decDuration)) %>% 
  ungroup()
# which(duplicated(dat$TripID) == TRUE) # Should be none

# allocating sites to grids
dat <- dat %>%
  st_join(gridID_vis, left = T, join = st_intersects)

# selecting attributes, and tidying
dat <- dat %>% 
  rename(gridID_vis = gridID_alt) %>% 
  dplyr::select(TripID, PersonID, gridID_vis, Site) %>% 
  distinct() %>% 
  mutate(BR = ifelse(Site %in% "Hillarys", "104", NA),
         BR = ifelse(Site %in% "Mindarie", "105", BR),
         BR = ifelse(Site %in% "OceanReef", "106", BR),
         BR = ifelse(Site %in% "TwoRocks", "112", BR)) %>% 
  # mutate(UseLong = st_coordinates(.)[,1]) %>% 
  # mutate(UseLat = st_coordinates(.)[,2]) %>% 
  dplyr::select(-Site) %>% 
  as.data.frame()

# which(is.na(dat$gridID_vis)==TRUE)
# this chunk should give you a data set with one trip per row, with a few trip/fisher attributes and the ID of visited grids 
```

# Join data
```{r join}
og_dat <- dat # copying original data test join

dat <- inner_join(dat, sites, by = "BR") # FALSE

# testing join
a <- as.data.frame(table(og_dat$BR)) %>% rename(launches = Freq)
b <- as.data.frame(table(sites$BR)) %>%  rename(n_sites = Freq)
c <- left_join(a, b)
c$times <- c$launches*c$n_sites
test = sum(c$times)
test == nrow(dat) # this should be TRUE

# ggplot() +
#   geom_sf(data = sites) +
#   geom_sf(data = dat$geometry)
```

# Getting distance from BR to mean coordinate of all uses that launched from teh same boat ramp
```{r}
dat <- dat %>% 
  st_as_sf() # turn to sf object

# get centroid of use points
tmp <- dat %>%
  group_by(gridID_vis, BR) %>%
  summarise(use_centroid = st_union(geometry)) %>%
  st_centroid() %>%
  ungroup() %>%
  mutate(id = row_number())

# making distance data frame
dist <- as.data.frame(set_units(st_distance(tmp, BR), km)) # distance from use centroid to each BR
names(dist) <- unique(BR$RampID) 
dist$gridID_vis <- tmp$gridID_vis 
dist$BR <- tmp$BR 
dist$id <- tmp$id 
len <- length(dist) - 3 
dist <- dist %>% gather("BRdist", "use.centroid_km.BR", 1:len) # gather
dist$use.centroid_km.BR <- as.numeric(dist$use.centroid_km.BR) 

dist <- dist %>% 
  filter(BR == BRdist) %>% 
  dplyr::select(gridID_vis, BR, use.centroid_km.BR) %>% 
  rename(gridID_alt = gridID_vis) # got to join to alt not visited

dat <- as.data.frame(dat)

dat <- left_join(dat, dist, by = c("BR", "gridID_alt")) # join

dat <- dat %>% 
  mutate(site.centroid_km.BR = as.numeric(site.centroid_km.BR)) %>% 
  mutate(km_BR = ifelse(is.na(use.centroid_km.BR), site.centroid_km.BR, use.centroid_km.BR)) # distance tc to be measured from
```

# Choice and travel cost ($0.54/km)
```{r choice and travel cost}
dat <- dat %>% 
  # mutate(centroidLong = st_coordinates(polyCentroid)[,1]) %>% # need this is using dynamic variables
  # mutate(centroidLat = st_coordinates(polyCentroid)[,2]) %>%
  mutate(choice = ifelse(gridID_vis == gridID_alt, 1, 0)) %>% 
  mutate(travelCost = as.numeric(0.54*km_BR)) %>% 
  dplyr::select(-c(geometry, site.centroid_km.BR, use.centroid_km.BR))
```

```{r}
saveRDS(dat, "./data/gpkg/2.1_acChoiceSet_4283.gpkg")
```

# Save output
```{r save}
write_csv(dat, "./data/02_data/2.1_acdat.csv")
```